---
layout: page
title: zkClient
subtitle: zkClient
date: 2018-11-04 15:17:19
author: donaldhan
catalog: true
category: Zookeeper
categories:
    - Zookeeper
tags:
    - ZkClient
---

# 引言
前一篇文章，我们分析了一下Zookeeper原生API，先来回顾一下：
Zookeeper主要有两个成员分别为客户端和watcher管理器。watcher观察器，主要关注点的事件类型有节点创建NodeCreated，节点删除NodeDeleted，节点数据改变NodeDataChanged，
节点子节点更新事件类型NodeChildrenChanged；客户端状态有：同步连接SyncConnected，断开连接Disconnected，只读连接ConnectedReadOnly，验证失败AuthFailed，已验证SaslAuthenticated，会话过期Expired等状态。
Watcher观察者管理器ZKWatchManager，主要根据事件类型，注册节点观察器，默认为节点数据观察器集，节点存在观察器集，节点孩子节点观察器集，默认观察期器集；如果是NodeCreated和NodeDeleted，则注册节点数据观察器集，节点存在观察器集；
如果是NodeDataChanged，则注册节点孩子节点观察器集；如果是NodeDeleted，则注册节点数据观察器集，节点存在观察器集，节点孩子节点观察器集。

客户端ClientCnxn中最重要的是发送线程SendThread和事件线程EventThread，同时关联一个ZooKeeper，以及客户端watcher管理器ClientWatchManager，实际为ZKWatchManager，
还有一个我们需要关注的点是等待发送数据包队列pendingQueue（LinkedList<Packet>）和需要被发送的数据包队列outgoingQueue(LinkedList<Packet>)。

数据包Packet主要有请求头部requestHeader（RequestHeader），响应头部replyHeader（ReplyHeader），请求request（Record），响应response（Record），字节缓冲区ByteBuffer，客户端路径clientPath，服务端路径serverPath，异步回调接口AsyncCallback，数据包上下文，观察者注册器watchRegistration。

发送线程SendThread主要的作用是发送客户端请求数据包，实际委托给内部的clientCnxnSocket。

客户端socket的主要功能为发送数据包sendPacket和调度数据包队列doTransport。

客户端Socket的实现ClientCnxnSocketNIO，内部主要使用nio的选择器和选择key。

发送数据包，实际委托给内Socket通道。

调度数据包队列，实际委托给内Socket通道，如果是响应消息，则转化为响应Record，如果是发送数据包，则委托给内部的socket通道。

事件线程主要处理创建、设值,获取节点数据和获取节点子节点数据，检查节点是否存在，删除节点等事件，并处理。

启动客户端Socket，实际上启动发送数据包线程（处理数据的请求和响应）和事件线程（处理crwda相关事件）。

创建节点，创建创建请求和响应，委托给socket客户端，发送创建节点操作。

Zk的crwda的相关操作，首先创建相应类型的请求和响应，然后委托给socket客户端，处理响应的操作，并解析响应消息。

今天我们主要来看一下ZkClient。
ZkClient是由Datameer的工程师开发的开源客户端，对Zookeeper的原生API进行了包装。
相对于原生api优势：
1. 实现了超时重连、Watcher反复注册等功能。
2. 添加序列化支持。
3. 同时可以递归创建和删除路径。

这篇文章所有使用的示例代码可以参考[zookeeper-demo][]。

[zookeeper-demo]:https://github.com/Donaldhan/zookeeper-demo "zookeeper-demo"
[Zookeeper原生API]:https://donaldhan.github.io/zookeeper/2018/06/14/Zookeeper%E5%8E%9F%E7%94%9FAPI.html "Zookeeper原生API"


# 目录
* [ZkClient客户端](#zkclient客户端)
    * [ZkClient的成员变量](#zkclient的成员变量)
    * [会话连接ZkConnection](#会话连接zkconnection)
    * [](#)
    * [](#)
    * [](#)
* [总结](#总结)

## ZkClient客户端
一般我们创建ZkClient客户端如下：

```java
/**
 * @ClassName: CreateNodeSample
 * @Description: 使用ZkClient创建节点，注意：当递归创建持久化路径的方法传入的createParents为true时，节点已经存在，不会抛出异常。
 * @Author: Donaldhan
 * @Date: 2018-05-13 19:28
 */
@Slf4j
public class CreateNodeSample {
    private static ZkClient zkClient;
    public static void main(String[] args) {
        try {
            zkClient = new ZkClient(ConfigConstant.IP, ConfigConstant.SESSION_TIMEOUT);
            log.info("success connected ...");
            String path = "/zk-book/c1";
            //如果父节点不存在，可以创建父节点
            zkClient.createPersistent(path, true);
            log.info("success create:{} ...",path);
        } catch (RuntimeException e) {
            e.printStackTrace();
        } finally {
            if (zkClient != null) {
                zkClient.close();
            }
        }
    }
}
```
从上面示例，可以看出，主要客户端为ZkClient。

### ZkClient的成员变量
我们来看一下ZkClient的成员变量
```java
public class ZkClient implements Watcher {
   protected IZkConnection _connection;//客户端连接
   //子节点监听器集
   private final Map<String, Set<IZkChildListener>> _childListener = new ConcurrentHashMap<String, Set<IZkChildListener>>();
   //节点数据监听器集
   private final ConcurrentHashMap<String, Set<IZkDataListener>> _dataListener = new ConcurrentHashMap<String, Set<IZkDataListener>>();
   //节点状态监听器集
   private final Set<IZkStateListener> _stateListener = new CopyOnWriteArraySet<IZkStateListener>();
   private KeeperState _currentState;//当前状态
   private final ZkLock _zkEventLock = new ZkLock();//事件锁
   private boolean _shutdownTriggered;
   private ZkEventThread _eventThread;//事件线程
   // TODO PVo remove this later
   private Thread _zookeeperEventThread;
   private ZkSerializer _zkSerializer;//序列化器
}
```
从上面可以看出Zk客户端ZkClient主要的成员变量为：客户端连接IZkConnection，子节点监听器集IZkChildListener，节点数据监听器集IZkDataListener，当前状态KeeperState，事件锁ZkLock，
客户端状态监听器集IZkStateListener，事件线程ZkEventThread，序列化器ZkSerializer,最要的一点实现了 *Watcher* 接口。。

再往下看之前我们，先把子节点监听器IZkChildListener，节点数据监听器IZkDataListener，
客户端状态监听器IZkStateListener，序列化器ZkSerializer的定义看一下。

#### 节点数据监听器IZkDataListener

```java
public interface IZkDataListener {
    public void handleDataChange(String dataPath, Object data) throws Exception;
    public void handleDataDeleted(String dataPath) throws Exception;
}
```
节点数据监听器IZkDataListener,主要监控节点数据的变化，包括创建，变更，和删除事件。

#### 子节点监听器IZkChildListener
```java
public interface IZkChildListener {

    /**
     * Called when the children of the given path changed.
     *
     * @param parentPath
     *            The parent path
     * @param currentChilds
     *            The children or null if the root node (parent path) was deleted.
     * @throws Exception
     */
    public void handleChildChange(String parentPath, List<String> currentChilds) throws Exception;
}
```
子节点监听器IZkChildListener，监控路径子节点的变化，包括创建，变更，和删除事件。

#### 客户端状态监听器IZkStateListener
```java
public interface IZkStateListener {

    /**
     * Called when the zookeeper connection state has changed.
     *
     * @param state
     *            The new state.
     * @throws Exception
     *             On any error.
     */
    public void handleStateChanged(KeeperState state) throws Exception;

    /**
     * Called after the zookeeper session has expired and a new session has been created. You would have to re-create
     * any ephemeral nodes here.
     *
     * @throws Exception
     *             On any error.
     */
    public void handleNewSession() throws Exception;
}
```
客户端状态监听器IZkStateListener，处理连接状态的变更，并在会话过期时，重新创建连接。

#### 事件锁ZkLock
```java
public class ZkLock extends ReentrantLock {

    private static final long serialVersionUID = 1L;

    private Condition _dataChangedCondition = newCondition();
    private Condition _stateChangedCondition = newCondition();
    private Condition _zNodeEventCondition = newCondition();

    /**
     * This condition will be signaled if a zookeeper event was processed and the event contains a data/child change.
     *
     * @return the condition.
     */
    public Condition getDataChangedCondition() {
        return _dataChangedCondition;
    }

    /**
     * This condition will be signaled if a zookeeper event was processed and the event contains a state change
     * (connected, disconnected, session expired, etc ...).
     *
     * @return the condition.
     */
    public Condition getStateChangedCondition() {
        return _stateChangedCondition;
    }

    /**
     * This condition will be signaled if any znode related zookeeper event was received.
     *
     * @return the condition.
     */
    public Condition getZNodeEventCondition() {
        return _zNodeEventCondition;
    }
}
```
从上面可以看出，事件锁，为可重入锁，有三个条件，分别为节点数据变更，会话状态变更，节点事件条件。


#### 序列化器ZkSerializer
```java
/**
 * Zookeeper is able to store data in form of byte arrays. This interfacte is a bridge between those byte-array format
 * and higher level objects.
 *
 * @see BytesPushThroughSerializer
 * @see SerializableSerializer
 */
public interface ZkSerializer {

    public byte[] serialize(Object data) throws ZkMarshallingError;

    public Object deserialize(byte[] bytes) throws ZkMarshallingError;
}
```
序列化器ZkSerializer,用于序列化，发送给Zkserver的数据，反序列化，从zk服务器接受的数据。

客户端连接IZkConnection，事件线程ZkEventThread这个我们在后面用到的时候，再讲。

再来看Zkclient的构造

```java
public ZkClient(String serverstring) {
    this(serverstring, Integer.MAX_VALUE);
}

public ZkClient(String zkServers, int connectionTimeout) {
    this(new ZkConnection(zkServers), connectionTimeout);
}

public ZkClient(String zkServers, int sessionTimeout, int connectionTimeout) {
    this(new ZkConnection(zkServers, sessionTimeout), connectionTimeout);
}

public ZkClient(String zkServers, int sessionTimeout, int connectionTimeout, ZkSerializer zkSerializer) {
    this(new ZkConnection(zkServers, sessionTimeout), connectionTimeout, zkSerializer);
}

public ZkClient(IZkConnection connection) {
    this(connection, Integer.MAX_VALUE);
}

public ZkClient(IZkConnection connection, int connectionTimeout) {
    this(connection, connectionTimeout, new SerializableSerializer());
}

public ZkClient(IZkConnection zkConnection, int connectionTimeout, ZkSerializer zkSerializer) {
    _connection = zkConnection;
    _zkSerializer = zkSerializer;
    connect(connectionTimeout, this);
}
```  
Zkclient的构造，主要是初始化Zk会话连接，会话超时时间和会话连接超时时间。默认的序列化器为SerializableSerializer，同时我们可以自己实现字节的序列化器。

来看一下默认的序列化器
```java
public class SerializableSerializer implements ZkSerializer {

    @Override
    public Object deserialize(byte[] bytes) throws ZkMarshallingError {
        try {
            ObjectInputStream inputStream = new ObjectInputStream(new ByteArrayInputStream(bytes));
            Object object = inputStream.readObject();
            return object;
        } catch (ClassNotFoundException e) {
            throw new ZkMarshallingError("Unable to find object class.", e);
        } catch (IOException e) {
            throw new ZkMarshallingError(e);
        }
    }

    @Override
    public byte[] serialize(Object serializable) throws ZkMarshallingError {
        try {
            ByteArrayOutputStream byteArrayOS = new ByteArrayOutputStream();
            ObjectOutputStream stream = new ObjectOutputStream(byteArrayOS);
            stream.writeObject(serializable);
            stream.close();
            return byteArrayOS.toByteArray();
        } catch (IOException e) {
            throw new ZkMarshallingError(e);
        }
    }

}
```
这个一看就明白，我们再来看ZkClient会话连接ZkConnection。

## 会话连接ZkConnection

再看会话连接以前，先来看接口IZkConnection的定义：
```java
public interface IZkConnection {

    public void connect(Watcher watcher);

    void close() throws InterruptedException;

    public String create(String path, byte[] data, CreateMode mode) throws KeeperException, InterruptedException;

    public void delete(String path) throws InterruptedException, KeeperException;

    boolean exists(final String path, final boolean watch) throws KeeperException, InterruptedException;

    List<String> getChildren(final String path, final boolean watch) throws KeeperException, InterruptedException;

    public byte[] readData(String path, Stat stat, boolean watch) throws KeeperException, InterruptedException;

    public void writeData(String path, byte[] data, int expectedVersion) throws KeeperException, InterruptedException;

    public States getZookeeperState();

    public long getCreateTime(String path) throws KeeperException, InterruptedException;

    public String getServers();
}
```
从上面可以看出，会话接口IZkConnection，主要提供了ZK的CRWDA操作，这个与[Zk原生API的客户端socket][]作用相同。

[Zk原生API的客户端socket]:https://donaldhan.github.io/zookeeper/2018/06/14/Zookeeper%E5%8E%9F%E7%94%9FAPI.html#clientcnxn "Zk原生API的客户端socket"

我们回到会话连接ZkConnection的定义：
```java
public class ZkConnection implements IZkConnection {

    private static final Logger LOG = Logger.getLogger(ZkConnection.class);

    /** It is recommended to use quite large sessions timeouts for ZooKeeper. */
    private static final int DEFAULT_SESSION_TIMEOUT = 30000;

    private ZooKeeper _zk = null;
    private Lock _zookeeperLock = new ReentrantLock();

    private final String _servers;
    private final int _sessionTimeOut;

    public ZkConnection(String zkServers) {
        this(zkServers, DEFAULT_SESSION_TIMEOUT);
    }

    public ZkConnection(String zkServers, int sessionTimeOut) {
        _servers = zkServers;
        _sessionTimeOut = sessionTimeOut;
    }
}
```



### 事件线程ZkEventThread

### ZkClient Watcher接口


[]: ""

```java
```




[]: ""

```java
```


## 总结
Zk客户端ZkClient主要的成员变量为,客户端连接IZkConnection，子节点监听器集IZkChildListener，节点数据监听器集IZkDataListener，当前状态KeeperState，事件锁ZkLock，
客户端状态监听器集IZkStateListener，事件线程ZkEventThread，序列化器ZkSerializer,最要的一点实现了 *Watcher* 接口。

节点数据监听器IZkDataListener,主要监控节点数据的变化，包括创建，变更，和删除事件。

子节点监听器IZkChildListener，监控路径子节点的变化，包括创建，变更，和删除事件。

客户端状态监听器IZkStateListener，处理连接状态的变更，并在会话过期时，重新创建连接。


事件锁，为可重入锁，有三个条件，分别为节点数据变更，会话状态变更，节点事件条件。

序列化器ZkSerializer,用于序列化，发送给Zkserver的数据，反序列化，从zk服务器接受的数据。

Zkclient的构造，主要是初始化Zk会话连接，会话超时时间和会话连接超时时间。默认的序列化器为SerializableSerializer，同时我们可以自己实现字节的序列化器。

会话接口IZkConnection，主要提供了ZK的CRWDA操作，这个与[Zk原生API的客户端socket][]作用相同。
