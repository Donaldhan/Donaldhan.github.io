---
layout: page
title: Curator
subtitle: Curator
date: 2018-06-18 12:16:00
author: donaldhan
catalog: true
category: Zookeeper
categories:
    - Zookeeper
tags:
    - ZkClient
---

# 引言
前一篇文章，我们分析了一下Zookeeper客户端[ZkClient][]，先来回顾一下：

Zk客户端ZkClient主要的成员变量为,客户端连接IZkConnection，子节点监听器集IZkChildListener，节点数据监听器集IZkDataListener，当前状态KeeperState，事件锁ZkLock，
客户端状态监听器集IZkStateListener，事件线程ZkEventThread，序列化器ZkSerializer,最要的一点实现了 *Watcher* 接口。

节点数据监听器IZkDataListener,主要监控节点数据的变化，包括创建，变更，和删除事件。

子节点监听器IZkChildListener，监控路径子节点的变化，包括创建，变更，和删除事件。

客户端状态监听器IZkStateListener，处理连接状态的变更，并在会话过期时，重新创建连接。

事件锁，为可重入锁，有三个条件，分别为节点数据变更，会话状态变更，节点事件条件。

序列化器ZkSerializer,用于序列化，发送给Zkserver的数据，反序列化，从zk服务器接受的数据。

Zkclient的构造，主要是初始化Zk会话连接，会话超时时间和会话连接超时时间。默认的序列化器为SerializableSerializer，同时我们可以自己实现字节的序列化器。

会话接口IZkConnection，主要提供了ZK的CRWDA操作，这个与[Zk原生API的客户端socket][]作用相同。

ZkClient会话客户端ZkConnection，主要成员变量，一个为远程Zk客户端ZooKeeper，一个用户控制会话连接与关闭的可重入锁ReentrantLock。
连接操作，主要是创建原生Zookeeper客户端，关闭操作实际，是关闭原生Zookeeper客户端。
CDRWA操作实际委托给内部的原生Zookeeper客户端，ZkClient会话客户端连接ZkConnection，面向的能染是字节流。
创建zk目录时，我们可以根据布尔参数createParents，来决定是否需要创建父目录，实际操作委托给内部的ZkClient会话连接。
删除操作，当会话失去连接时，重新连接，通过回调再执行删除目录操作，实际操作委托给内部的ZkClient会话连接。
检查目录是否存在操作，当会话失去连接时，重新连接，通过回调再执行检查目录操作，实际操作委托给内部的ZkClient会话连接。
读操作的如果失去连接，则重新连接，连接成功后，通过回调，委托ZkClient会话读取目录数据，如果存在目录监听器，则触发目录监听器，同时反序列化读取的字节序列。
写操作先序列化数据，如果失去连接，则重新连接，连接成功后，通过回调，委托ZkClient会话写目录数据。

事件线程ZkEventThread内部有一个zk事件ZkEvent队列LinkedBlockingQueue<ZkEvent>，事件线程的主要任务是，消费zk事件ZkEvent队列中的
事件，并执行相应的事件。

ZkClient实现Watcher的目的主要处理目录变更和会话状态变更相关事件，对于在会话关闭时，触发的事件，直接丢弃。
状态变更事件处理，主要是将触发状态监听任务保证成ZK事件ZkEvent，放入事件线程的事件队列中，如果会话过期，则重新连接。

触发目录变更及子目录变更事件的原理和状态变更基本相同，都是将触发监听器操作包装成包装成ZK事件ZkEvent，放入事件线程ZkEventThread的事件队列中，对于目录变更事件，则重新注册监听器，
从而避免了原生API的重复注册的弊端。

这篇文章所有使用的示例代码可以参考[zookeeper-demo][]。

[zookeeper-demo]:https://github.com/Donaldhan/zookeeper-demo "zookeeper-demo"
[Zookeeper原生API]:https://donaldhan.github.io/zookeeper/2018/06/14/Zookeeper%E5%8E%9F%E7%94%9FAPI.html "Zookeeper原生API"
[ZkClient]:https://donaldhan.github.io/zookeeper/2018/11/04/ZkClient.html "ZkClient"





# 目录
* [Curator](#Curator)
    * [](#)
    * [](#)
* [总结](#总结)

## Curator

Curator是Netflix公司开源的一个Zookeeper客户端，与Zookeeper提供的原生客户端相比，Curator的抽象层次更高，简化了Zookeeper客户端编程。
Curator是对ZK的高阶封装. 与操作原生的Zookeeper相比, 它提供了对ZK的完美封装, 简化了对集群的连接, 错误的处理; 实现了一系列经典"模式", 比如分布式锁, Leader选举等。
ZooKeeper本身自带一个Java客户端，但使用这个客户端繁琐而且容易出错。客户端的使用者需要做大量的手动维护性工作。比如：

* 连接问题

    初始化连接：ZooKeeper客户端与服务器进行握手，这需要花一些时间。如果握手未完成，任何要与服务器端同步执行的方法(如，create()，getData()等)都会抛出异常。
    Failover：如果ZooKeeper客户端与服务器连接断开，它会failover到集群中另外一台服务器。然后，这个过程会使客户端退回到”初始化连接”的模式。
    Session过期：有些边际情况可以导致ZooKeeper session过期。客户端需要监视这个状态，关闭并重建ZooKeeper客户端实例。

* 恢复问题

    当在Server创建顺序节点(sequential ZNode)时，有可能出现这种情况：节点成功创建了，但server在将节点名返回给客户端之前崩溃了。
    ZooKeeper客户端可能会抛出几个可恢复的异常，使用者需要捕捉这些异常并做重试操作。

* Recipe方面

    标准的ZooKeeper recipe(如锁，选leader等)只是得到最低程序的描述，要正确地编写出来比较困难。
    有一些重要的边界情况在recipe描述里没有提到。例如，锁recipe的描述中，没有说到如何处理服务器成功创建了顺序(Sequential)/临时(Ephemeral)节点，但在向客户端返回结点名之前就崩溃的情况。如果没有得到正确处理，可能会导致死锁。
    某些使用场景下，必须要注意可能出现的连接问题。例如，选leader过程要监视连接的稳定性。如果连接到的服务器崩溃了，leader就不能假定自己继续为leader，除非已经成功failover到另外的服务器。

上述问题(和其它类似的问题)必须由每个ZooKeeper使用者来处理。问题解决方案既不容易编写，也不是显而易见的，需要消耗相当多的时间。而Curator处理了所有的问题。
Curator是什么

Curator n ˈkyoor͝ˌātər:，展品或者其它收藏品的看守者，管理员，ZooKeeper的Keeper。它由3个相关的项目组成：
    1. curator-client - ZooKeeper自带客户端的替代者，它负责处理低层次的维护工作，并提供某些有用的小功能
    2. curator-framework - Curator Framework大大地简化ZooKeeper使用的高层次API。它在ZooKeeper客户端之上添加了很多功能，并处理了与ZooKeeper集群连接管理和重试操作的复杂性。
    3. curator-recipes - ZooKeeper某些通用recipe的实现。它是基于Curator Framework之上实现的。

Curator专注于锁，选Leader等这些recipe。大部分对ZooKeeper感兴趣的人不需要关心连接管理等细节。他们想要的只是简单的使用这些recipe。Curator就是以此作为目标。

Curator通过以下方式处理了使用ZooKeeper的复杂度：

    1. 重试机制：Curator支持可插拔式的(pluggable)重试机制。所有会产生可恢复异常的ZooKeeper操作都会在配置好的重试策略下得到重试。Curator自带了几个标准的重试策略(如二元指数后退策略)。
    2. 连接状态监视：Curator不断监视ZooKeeper连接的状态，Curator用户可以监听连接状态变化并相应的作出回应。
    3. ZooKeeper客户端实例管理：Curator通过标准的ZooKeeper类实例来管理与ZooKeeper集群的实际连接。然而，这些实例是管理在内部(尽管你若需要也可以访问)，在需要的时候被重新创建。因此，Curator提供了对ZooKeeper集群的可靠处理(不像ZooKeeper自带的实现)。
    4. 正确，可靠的recipe：Curator实现了大部分重要的ZooKeeper recipe(还有一些附加的recipe)。它们的实现使用了ZooKeeper的最佳实践，处理了所有已知的边界情况(像前面所说的)。
    Curator专注于那些让你的代码更强健，因为你完全专心于你感兴趣的ZooKeeper功能，而不用担心怎么正确完成那些的维护性工作。

ZooKeeper在Netflix

ZooKeeper/Curator在Netflix得到了广泛的使用。使用情景有：
    1. InterProcessMutex在各种顺序ID生成器中被用来保证值的唯一性
    2. Cassandra备份
    3. TrackID服务
    4. Chukwa收集器使用LeaderSelector来做各种维护性的任务
我们用了一些第三方的服务，但它们只允许有限数目的并发用户。InterProcessSemphore被用来处理这个。各种Cache。



###


```java
```


###


```java
```


## 总结
