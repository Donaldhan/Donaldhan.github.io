---
layout: page
title: Curator目录监听
subtitle: Curator目录监听
date: 2018-06-29 09:40:19
author: donaldhan
catalog: true
category: Zookeeper
categories:
    - Zookeeper
tags:
    - ZkClient
---

# 引言
上一篇文章，我们简单看一下Curator的CDRWA相关的构造器，及Curator框架实现，[Curator][]框架工厂CuratorFrameworkFactory内部，主要成员变量为默认的会话超时与连接超时时间，本地地址，字节压缩器GzipCompressionProvider，
默认的Zookeeper工厂DefaultZookeeperFactory，默认ACL提供器DefaultACLProvider。GzipCompressionProvider用于压缩字节流。
默认的Zookeeper工厂DefaultZookeeperFactory，用于创建原生Zookeeper客户端。DefaultACLProvider主要用户获取节点的ACL权限。


CuratorFrameworkFactory内部构建器Builder，除了会话超时与连接超时时间，字节压缩器，原生API客户端工厂，
ACL提供器之外，还有线程工程ThreadFactory，验证方式，及验证值，及重试策略RetryPolicy。
ExponentialBackoffRetry主要用户控制会话超时重连的次数和下次尝试时间。
内部构建器Builder，创建的实际为CuratorFrameworkImpl。

CuratorFramework主要提供了启动关闭客户端操作，及CDRWA相关的构建器，如创建节点CreateBuilder，删除节点DeleteBuilder，获取节点数据GetDataBuilder，设置节点数据SetACLBuilder，
，检查节点ExistsBuilder，同步数据构建器SyncBuilder， 事物构建器CuratorTransaction，ACL构建器GetACLBuilder、SetACLBuilder，提供了客户端连接状态监听器Listenable<ConnectionStateListener>，
客户端监听器Listenable<CuratorListener> ，无处理错误监听器Listenable<UnhandledErrorListener>操作，同时提供了获取zk客户端和CuratorZookeeperClient和确保路径的操作EnsurePath。


Curator zk客户端CuratorZookeeperClient主要用于获取原生API ZK客户端，以及用于重新创建失效会话，执行相应的CDRWA操作。
创建构建器CreateBuilder，主要提供了创建持久化和临时节点的操作。

Curator框架实现CuratorFrameworkImpl，创建目录实际上委托给Curator框架内部的原生API zk客户端，如果需要创建建父目录，并且父目录不存在，则创建父目录。
如果会话失效，则重新建立会话，如果建立会话成功，则调用创建目录回调Callable。

删除构建器DeleteBuilder，删除目录，实际操作在一个重试循环中，如果会话过期，则重新连接会话，并将实际删除操作委托给Curator框架内部的原生API zk客户端。

Curator框架实现CuratorFrameworkImpl的获取目录数据操作，检查目录和设置目录数据的原理与创建、删除操作基本相同实际操作委托给Curator框架内部的原生API zk客户端，
并保证会话有效。 本文章所有的示例，参见[zookeeper-demo][]。
[zookeeper-demo]:https://github.com/Donaldhan/zookeeper-demo "zookeeper-demo"
[Curator]:https://donaldhan.github.io/zookeeper/2018/06/18/Curator.html "Curator"



# 目录
* [ Curator节点监听](#curator节点监听)
    * [节点监听器NodeCache](#节点监听器nodecache)
    * [一级目录监听器PathChildrenCache](#一级目录监听器pathchildrencache)
* [总结](#总结)

## Curator节点监听

curator官方推荐的API是对zookeeper原生的JAVA API进行了封装，将重复注册，事件信息等很好的处理了。而且监听事件返回了详细的信息，包括变动的节点路径，节点值等等，这是原生API所没有的。这个对事件的监听类似于一个本地缓存视图和远程Zookeeper视图的对比过程。curator的方法调用采用的是流式API，此种风格的优点及使用注意事项可自行查阅资料了解。对于目录的监听，curator提供了三个接口，分别如下：
1. NodeCache：对一个节点进行监听，监听事件包括指定路径的增删改操作；
2. PathChildrenCache：对指定路径节点的一级子目录监听，不对该节点的操作监听，对其子目录的增删改操作监听
3. TreeCache，综合NodeCache和PathChildrenCahce的特性，是对整个目录进行监听，可以设置监听深度。

下面我们来看几个示例：
### 监听节点数据变化
```java
package org.donald.curator.recipes.cache;

import lombok.extern.slf4j.Slf4j;
import org.apache.curator.RetryPolicy;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.recipes.cache.NodeCache;
import org.apache.curator.framework.recipes.cache.NodeCacheListener;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.apache.zookeeper.CreateMode;
import org.donald.constant.ConfigConstant;

import java.io.UnsupportedEncodingException;

/**
 * @ClassName: NodeCacheSample
 * @Description: 节点监听器，类似于原生Watcher
 * @Author: Donaldhan
 * @Date: 2018-05-16 8:24
 */
@Slf4j
public class NodeCacheSample {
    private static CuratorFramework client;
    public static void main(String[] args) {
        String path = "/zk-book/nodecache";
        try {
            RetryPolicy retryPolicy = new ExponentialBackoffRetry(ConfigConstant.BASE_SLEEP_TIMES, ConfigConstant.MAX_RETRIES);
            client =
                    CuratorFrameworkFactory.builder()
                            .connectString(ConfigConstant.IP)
                            .sessionTimeoutMs(ConfigConstant.SESSION_TIMEOUT)
                            .connectionTimeoutMs(ConfigConstant.CONNETING_TIMEOUT)
                            .retryPolicy(retryPolicy)
                            .build();
            log.info("success connected...");
            client.start();
            final NodeCache cache = new NodeCache(client,path,false);
            cache.getListenable().addListener(new NodeCacheListener() {
                @Override
                public void nodeChanged() throws UnsupportedEncodingException {
                    log.info("Node data update, new data: {}" , new String(cache.getCurrentData().getData(), ConfigConstant.CHAR_SET_NAME));
                }
            });
            //不要忘记启动cache
            cache.start(true);
            //如果需要创建父节点，需要注意一个问题，创建的父节点是持久化的
            client.create()
                    .creatingParentsIfNeeded()
                    .withMode(CreateMode.EPHEMERAL)
                    .forPath(path, "init".getBytes());
            log.info("success create:{}...", path);
            client.setData().forPath( path, "update".getBytes() );
            log.info("success update:{}...", path);
            Thread.sleep( 3000 );
            client.delete().deletingChildrenIfNeeded().forPath( path );
            log.info("success delete:{}...", path);
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (client != null) {
                client.close();
            }
        }
    }
}
```


### 监听节点不存在
```java
package org.donald.curator.recipes.cache;

import lombok.extern.slf4j.Slf4j;
import org.apache.curator.RetryPolicy;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.recipes.cache.NodeCache;
import org.apache.curator.framework.recipes.cache.NodeCacheListener;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.apache.zookeeper.CreateMode;
import org.donald.constant.ConfigConstant;

/**
 * @ClassName: NodeCacheNotExistsSample
 * @Description: 测试监听节点不存在的情况
 * @Author: Donaldhan
 * @Date: 2018-05-16 14:42
 */
@Slf4j
public class NodeCacheNotExistsSample {
    private static CuratorFramework client;
    public static void main(String[] args) {
        String path = "/curator_nodecache_sample";
        try {
            RetryPolicy retryPolicy = new ExponentialBackoffRetry(ConfigConstant.BASE_SLEEP_TIMES, ConfigConstant.MAX_RETRIES);
            client =
                    CuratorFrameworkFactory.builder()
                            .connectString(ConfigConstant.IP)
                            .sessionTimeoutMs(ConfigConstant.SESSION_TIMEOUT)
                            .connectionTimeoutMs(ConfigConstant.CONNETING_TIMEOUT)
                            .retryPolicy(retryPolicy)
                            .build();
            log.info("success connected...");
            client.start();
            final NodeCache cache = new NodeCache(client, path, false);
            cache.start(true);
            cache.getListenable().addListener(new NodeCacheListener() {
                @Override
                public void nodeChanged() {
                    log.info("Node data update, new data: {}", new String(cache.getCurrentData().getData()));
                }
            });
            client.create()
                    .creatingParentsIfNeeded()
                    .withMode(CreateMode.EPHEMERAL)
                    .forPath(path, "init".getBytes());
            Thread.sleep(6000);
            //使用过后，不要忘了关闭节点缓存
            cache.close();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (client != null) {
                client.close();
            }
        }
    }
}
```


### 监听一级目录


```java
package org.donald.curator.recipes.cache;

import lombok.extern.slf4j.Slf4j;
import org.apache.curator.RetryPolicy;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.recipes.cache.PathChildrenCache;
import org.apache.curator.framework.recipes.cache.PathChildrenCacheEvent;
import org.apache.curator.framework.recipes.cache.PathChildrenCacheListener;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.data.Stat;
import org.donald.constant.ConfigConstant;

/**
 * @ClassName: PathChildrenCacheSample
 * @Description: 监控路径子节点变化
 * @Author: Donaldhan
 * @Date: 2018-05-16 9:37
 */
@Slf4j
public class PathChildrenCacheSample {
    private static CuratorFramework client;
    public static void main(String[] args) {
        String path = "/zk-book";
        try {
            RetryPolicy retryPolicy = new ExponentialBackoffRetry(ConfigConstant.BASE_SLEEP_TIMES, ConfigConstant.MAX_RETRIES);
            client =
                    CuratorFrameworkFactory.builder()
                            .connectString(ConfigConstant.IP)
                            .sessionTimeoutMs(ConfigConstant.SESSION_TIMEOUT)
                            .connectionTimeoutMs(ConfigConstant.CONNETING_TIMEOUT)
                            .retryPolicy(retryPolicy)
                            .build();
            log.info("success connected...");
            client.start();
            PathChildrenCache cache = new PathChildrenCache(client, path, true);
            /**
             * After cache is primed with initial values (in the background) a
             * {@link PathChildrenCacheEvent.Type#INITIALIZED} will be posted
             */
            cache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);
            cache.getListenable().addListener(new PathChildrenCacheListener() {
                @Override
                public void childEvent(CuratorFramework client,
                                       PathChildrenCacheEvent event) throws Exception {
                    switch (event.getType()) {
                        case CHILD_ADDED:
                            String currentPathValue =  new String(client.getData().storingStatIn(new Stat()).forPath(path),ConfigConstant.CHAR_SET_NAME);
                            log.info("CHILD_ADDED,{},parent node data: {}",event.getData().getPath(), currentPathValue);
                            break;
                        case CHILD_UPDATED:
                            log.info("CHILD_UPDATED,{},vaule:{}",event.getData().getPath(), new String(event.getData().getData(),ConfigConstant.CHAR_SET_NAME));
                            break;
                        case CHILD_REMOVED:
                            log.info("CHILD_REMOVED,{}",event.getData().getPath());
                            break;
                        default:
                            break;
                    }
                }
            });
            client.create().withMode(CreateMode.PERSISTENT).forPath(path,"init".getBytes());
            log.info("success create /zk-book...");
            Thread.sleep( 1000 );
            client.create().withMode(CreateMode.PERSISTENT).forPath(path+"/c1");
            log.info("success create child c1...");
            Thread.sleep( 1000 );
            client.setData().forPath(path+"/c1","update".getBytes());
            log.info("success update child c1...");
            Thread.sleep( 1000 );
            client.create().withMode(CreateMode.PERSISTENT).forPath(path+"/c1/d1");
            log.info("success create child c1/d1 ...");
            Thread.sleep( 1000 );
            client.delete().forPath(path+"/c1/d1");
            log.info("success delete child c1/d1 ...");
            Thread.sleep( 1000 );
            client.delete().forPath(path+"/c1");
            log.info("success delete child c1 ...");
            Thread.sleep( 1000 );
            client.delete().forPath(path);
            log.info("success delete child /zk-book...");
            Thread.sleep( 3000 );
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (client != null) {
                client.close();
            }
        }
    }
}

```



### 监听一级目录，并使用执行器，执行相应的事件

```java
package org.donald.curator.recipes.cache;

import lombok.extern.slf4j.Slf4j;
import org.apache.curator.RetryPolicy;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.recipes.cache.PathChildrenCache;
import org.apache.curator.framework.recipes.cache.PathChildrenCacheEvent;
import org.apache.curator.framework.recipes.cache.PathChildrenCacheListener;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.apache.zookeeper.CreateMode;
import org.apache.zookeeper.data.Stat;
import org.donald.common.threadpool.TaskExecutors;
import org.donald.constant.ConfigConstant;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * @ClassName: PathChildrenCacheSample
 * @Description: 监控路径子节点变化,使用自定义线程池，执行监听事件
 * @Author: Donaldhan
 * @Date: 2018-05-16 9:37
 */
@Slf4j
public class PathChildrenCacheWithExecutorServiceSample {
    private static CuratorFramework client;
    private static ExecutorService exec = TaskExecutors.newFixedThreadPool(2);
    public static void main(String[] args) {
        String path = "/zk-book";
        try {
            RetryPolicy retryPolicy = new ExponentialBackoffRetry(ConfigConstant.BASE_SLEEP_TIMES, ConfigConstant.MAX_RETRIES);
            client =
                    CuratorFrameworkFactory.builder()
                            .connectString(ConfigConstant.IP)
                            .sessionTimeoutMs(ConfigConstant.SESSION_TIMEOUT)
                            .connectionTimeoutMs(ConfigConstant.CONNETING_TIMEOUT)
                            .retryPolicy(retryPolicy)
                            .build();
            log.info("success connected...");
            client.start();
            log.info( "current thread name:{} ", Thread.currentThread().getName() );
            PathChildrenCache cache = new PathChildrenCache(client, path, true, false, exec);
            /**
             * NORMAL,
             * cache will _not_ be primed. i.e. it will start empty and you will receive
             * events for all nodes added, etc.
             */
            cache.start(PathChildrenCache.StartMode.NORMAL);
            cache.getListenable().addListener(new PathChildrenCacheListener() {
                @Override
                public void childEvent(CuratorFramework client,
                                       PathChildrenCacheEvent event) throws Exception {
                    switch (event.getType()) {
                        case CHILD_ADDED:
                            String currentPathValue =  new String(client.getData().storingStatIn(new Stat()).forPath(path),ConfigConstant.CHAR_SET_NAME);
                            log.info("CHILD_ADDED,{},parent node data: {}",event.getData().getPath(), currentPathValue);
                            log.info( "current thread name:{} ", Thread.currentThread().getName() );
                            break;
                        case CHILD_UPDATED:
                            log.info("CHILD_UPDATED,{},vaule:{}",event.getData().getPath(), new String(event.getData().getData(),ConfigConstant.CHAR_SET_NAME));
                            log.info( "current thread name:{} ", Thread.currentThread().getName() );
                            break;
                        case CHILD_REMOVED:
                            log.info("CHILD_REMOVED,{}",event.getData().getPath());
                            log.info( "current thread name:{} ", Thread.currentThread().getName() );
                            break;
                        default:
                            break;
                    }
                }
            });
            client.create().withMode(CreateMode.PERSISTENT).forPath(path,"init".getBytes());
            log.info("success create /zk-book...");
            Thread.sleep( 1000 );
            client.create().withMode(CreateMode.PERSISTENT).forPath(path+"/c1");
            log.info("success create child c1...");
            Thread.sleep( 1000 );
            client.setData().forPath(path+"/c1","update".getBytes());
            log.info("success update child c1...");
            Thread.sleep( 1000 );
            client.create().withMode(CreateMode.PERSISTENT).forPath(path+"/c1/d1");
            log.info("success create child c1/d1 ...");
            Thread.sleep( 1000 );
            client.delete().forPath(path+"/c1/d1");
            log.info("success delete child c1/d1 ...");
            Thread.sleep( 1000 );
            client.delete().forPath(path+"/c1");
            log.info("success delete child c1 ...");
            Thread.sleep( 1000 );
            client.delete().forPath(path);
            log.info("success delete child /zk-book...");
            Thread.sleep( 3000 );
        } catch (InterruptedException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (client != null) {
                client.close();
            }
        }
    }
}
```

上面几个示例，我们主要使用的是节点监听器NodeCache，和一级目录监听器PathChildrenCache。关键sql如下：

1. 节点监听器NodeCache
```java
final NodeCache cache = new NodeCache(client,path,false);
cache.getListenable().addListener(new NodeCacheListener() {
    @Override
    public void nodeChanged() throws UnsupportedEncodingException {
        log.info("Node data update, new data: {}" , new String(cache.getCurrentData().getData(), ConfigConstant.CHAR_SET_NAME));
    }
});
```

2. 一级目录监听器PathChildrenCache
```java
PathChildrenCache cache = new PathChildrenCache(client, path, true);
/**
  * After cache is primed with initial values (in the background) a
  * {@link PathChildrenCacheEvent.Type#INITIALIZED} will be posted
  */
cache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);
cache.getListenable().addListener(new PathChildrenCacheListener() {
     @Override
     public void childEvent(CuratorFramework client,
                            PathChildrenCacheEvent event) throws Exception {
         switch (event.getType()) {
             case CHILD_ADDED:
                 String currentPathValue =  new String(client.getData().storingStatIn(new Stat()).forPath(path),ConfigConstant.CHAR_SET_NAME);
                 log.info("CHILD_ADDED,{},parent node data: {}",event.getData().getPath(), currentPathValue);
                 break;
             case CHILD_UPDATED:
                 log.info("CHILD_UPDATED,{},vaule:{}",event.getData().getPath(), new String(event.getData().getData(),ConfigConstant.CHAR_SET_NAME));
                 break;
             case CHILD_REMOVED:
                 log.info("CHILD_REMOVED,{}",event.getData().getPath());
                 break;
             default:
                 break;
         }
     }
});
```

```java
PathChildrenCache cache = new PathChildrenCache(client, path, true, false, exec);
/**
  * NORMAL,
  * cache will _not_ be primed. i.e. it will start empty and you will receive
  * events for all nodes added, etc.
  */
cache.start(PathChildrenCache.StartMode.NORMAL);
cache.getListenable().addListener(new PathChildrenCacheListener() {
     @Override
     public void childEvent(CuratorFramework client,
                            PathChildrenCacheEvent event) throws Exception {
         switch (event.getType()) {
             case CHILD_ADDED:
                 String currentPathValue =  new String(client.getData().storingStatIn(new Stat()).forPath(path),ConfigConstant.CHAR_SET_NAME);
                 log.info("CHILD_ADDED,{},parent node data: {}",event.getData().getPath(), currentPathValue);
                 log.info( "current thread name:{} ", Thread.currentThread().getName() );
                 break;
             case CHILD_UPDATED:
                 log.info("CHILD_UPDATED,{},vaule:{}",event.getData().getPath(), new String(event.getData().getData(),ConfigConstant.CHAR_SET_NAME));
                 log.info( "current thread name:{} ", Thread.currentThread().getName() );
                 break;
             case CHILD_REMOVED:
                 log.info("CHILD_REMOVED,{}",event.getData().getPath());
                 log.info( "current thread name:{} ", Thread.currentThread().getName() );
                 break;
             default:
                 break;
         }
     }
});
```

下面我们分别来看节点监听器NodeCache
### 节点监听器NodeCache

1. 节点监听器NodeCache
```java
final NodeCache cache = new NodeCache(client,path,false);
cache.getListenable().addListener(new NodeCacheListener() {
    @Override
    public void nodeChanged() throws UnsupportedEncodingException {
        log.info("Node data update, new data: {}" , new String(cache.getCurrentData().getData(), ConfigConstant.CHAR_SET_NAME));
    }
});
```

先来看一下这个节点监听缓存的定义：
```java
public class NodeCache implements Closeable
{
    private final Logger log = LoggerFactory.getLogger(getClass());
    private final CuratorFramework client; //Curator框架客户端
    private final String path;
    private final boolean dataIsCompressed;
    private final EnsurePath ensurePath;
    private final AtomicReference<ChildData> data = new AtomicReference<ChildData>(null);
    private final AtomicReference<State> state = new AtomicReference<State>(State.LATENT);//监听状态
    //节点监听器容器
    private final ListenerContainer<NodeCacheListener> listeners = new ListenerContainer<NodeCacheListener>();
    private final AtomicBoolean isConnected = new AtomicBoolean(true);
    //连接状态监听器
    private final ConnectionStateListener connectionStateListener = new ConnectionStateListener()
    {
        @Override
        public void stateChanged(CuratorFramework client, ConnectionState newState)
        {
            if ( (newState == ConnectionState.CONNECTED) || (newState == ConnectionState.RECONNECTED) )
            {
                if ( isConnected.compareAndSet(false, true) )
                {
                    try
                    {
                        reset();
                    }
                    catch ( Exception e )
                    {
                        log.error("Trying to reset after reconnection", e);
                    }
                }
            }
            else
            {
                isConnected.set(false);
            }
        }
    };

    private final CuratorWatcher watcher = new CuratorWatcher()
    {
        @Override
        public void process(WatchedEvent event) throws Exception
        {
            reset();
        }
    };

    private enum State
    {
        LATENT,
        STARTED,
        CLOSED
    }

    private final BackgroundCallback backgroundCallback = new BackgroundCallback()
    {
        @Override
        public void processResult(CuratorFramework client, CuratorEvent event) throws Exception
        {
            processBackgroundResult(event);
        }
    };

    /**
     * @param client curztor client
     * @param path the full path to the node to cache
     */
    public NodeCache(CuratorFramework client, String path)
    {
        this(client, path, false);
    }

    /**
     * @param client curztor client
     * @param path the full path to the node to cache
     * @param dataIsCompressed if true, data in the path is compressed
     */
    public NodeCache(CuratorFramework client, String path, boolean dataIsCompressed)
    {
        this.client = client;
        this.path = path;
        this.dataIsCompressed = dataIsCompressed;
        ensurePath = client.newNamespaceAwareEnsurePath(path).excludingLast();
    }
}
//节点缓存监听器
public interface NodeCacheListener
{
    /**
     * Called when a change has occurred
     */
    public void     nodeChanged() throws Exception;
}

```
从上面可以看出节点监听缓存NodeCache，内部关联一下Curator框架客户端CuratorFramework，节点监听器容器 listeners（ListenerContainer<NodeCacheListener>），用于
存放节点监听器。

再来看一下添加节点监听器
```java
```

再来看一下节点监听缓存NodeCache启动
```java
cache.getListenable().addListener(new NodeCacheListener() {
     @Override
     public void nodeChanged() throws UnsupportedEncodingException {
         log.info("Node data update, new data: {}" , new String(cache.getCurrentData().getData(), ConfigConstant.CHAR_SET_NAME));
     }
});

//NodeCache
/**
  * Return the cache listenable
  *
  * @return listenable
  */
public ListenerContainer<NodeCacheListener> getListenable()
{
     Preconditions.checkState(state.get() != State.CLOSED, "Closed");

     return listeners;
}
//ListenerContainer

public class ListenerContainer<T> implements Listenable<T>
{
    private final Logger                        log = LoggerFactory.getLogger(getClass());
    private final Map<T, ListenerEntry<T>>      listeners = Maps.newConcurrentMap();

    @Override
    public void addListener(T listener)
    {
        addListener(listener, MoreExecutors.sameThreadExecutor());
    }

    @Override
    public void addListener(T listener, Executor executor)
    {
        listeners.put(listener, new ListenerEntry<T>(listener, executor));
    }
    ...
}
```
从上面可以看出，添加节点监听器，实际上是注册到节点缓存的节点监听器容器ListenerContainer<NodeCacheListener>中。

再来看一下启动节点缓存
```java
/**
     * Same as {@link #start()} but gives the option of doing an initial build
     *
     * @param buildInitial if true, {@link #rebuild()} will be called before this method
     *                     returns in order to get an initial view of the node
     * @throws Exception errors
     */
    public void     start(boolean buildInitial) throws Exception
    {
        Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED), "Cannot be started more than once");

        ensurePath.ensure(client.getZookeeperClient());

        client.getConnectionStateListenable().addListener(connectionStateListener);

        if ( buildInitial )
        {
            internalRebuild();
        }
        reset();
    }
//
public class CuratorFrameworkImpl implements CuratorFramework
{
    private final Logger                                                log = LoggerFactory.getLogger(getClass());
    private final CuratorZookeeperClient                                client;
    private final ListenerContainer<CuratorListener>                    listeners;
    private final ListenerContainer<UnhandledErrorListener>             unhandledErrorListeners;
    private final ThreadFactory                                         threadFactory;
    private final BlockingQueue<OperationAndData<?>>                    backgroundOperations;
    private final NamespaceImpl                                         namespace;
    private final ConnectionStateManager                                connectionStateManager;
@Override
   public Listenable<ConnectionStateListener> getConnectionStateListenable()
   {
       return connectionStateManager.getListenable();
   }
   ...
}
```
从上面可以看出，启动节点监听器，实际上是注册节点监听器到CuratorFramework实现的连接状态管理器中ConnectionStateManager。

我们再来看，注册的监听器，是如何触发的，这个我们要回到CuratorFramework实现启动

```java
//CuratorFrameworkImpl
public class CuratorFrameworkImpl implements CuratorFramework
{
    private final Logger                                                log = LoggerFactory.getLogger(getClass());
    private final CuratorZookeeperClient                                client;//zk客户端
    private final ListenerContainer<CuratorListener>                    listeners;//Curator监听器
    private final ListenerContainer<UnhandledErrorListener>             unhandledErrorListeners;
    private final ThreadFactory                                         threadFactory;
    private final BlockingQueue<OperationAndData<?>>                    backgroundOperations;
    private final NamespaceImpl                                         namespace;
    private final ConnectionStateManager                                connectionStateManager;//连接状态管理器
    private final AtomicReference<AuthInfo>                             authInfo = new AtomicReference<AuthInfo>();
    private final byte[]                                                defaultData;
    private final FailedDeleteManager                                   failedDeleteManager;
    private final CompressionProvider                                   compressionProvider;
    private final ACLProvider                                           aclProvider;
    private final NamespaceFacadeCache                                  namespaceFacadeCache;
    private final NamespaceWatcherMap                                   namespaceWatcherMap = new NamespaceWatcherMap(this);
    private volatile ExecutorService                                    executorService;

    @Override
    public void     start()
    {
        log.info("Starting");
        if ( !state.compareAndSet(CuratorFrameworkState.LATENT, CuratorFrameworkState.STARTED) )
        {
            IllegalStateException error = new IllegalStateException();
            log.error("Cannot be started more than once", error);
            throw error;
        }

        try
        {
            //启动连接状态管理器
            connectionStateManager.start(); // ordering dependency - must be called before client.start()
            //启动客户端
            client.start();
            executorService = Executors.newFixedThreadPool(2, threadFactory);  // 1 for listeners, 1 for background ops
            executorService.submit
            (
                new Callable<Object>()
                {
                    @Override
                    public Object call() throws Exception
                    {
                        backgroundOperationsLoop();
                        return null;
                    }
                }
            );
        }
        catch ( Exception e )
        {
            handleBackgroundOperationException(null, e);
        }
    }
    public CuratorFrameworkImpl(CuratorFrameworkFactory.Builder builder)
   {
       ZookeeperFactory localZookeeperFactory = makeZookeeperFactory(builder.getZookeeperFactory());
       //初始化客户端
       this.client = new CuratorZookeeperClient
       (
           localZookeeperFactory,
           builder.getEnsembleProvider(),
           builder.getSessionTimeoutMs(),
           builder.getConnectionTimeoutMs(),
           //关键点
           new Watcher()
           {
               @Override
               public void process(WatchedEvent watchedEvent)
               {
                   //包装原生WatchedEvent事件为CuratorEvent
                   CuratorEvent event = new CuratorEventImpl
                   (
                       CuratorFrameworkImpl.this,
                       CuratorEventType.WATCHED,
                       watchedEvent.getState().getIntValue(),
                       unfixForNamespace(watchedEvent.getPath()),
                       null,
                       null,
                       null,
                       null,
                       null,
                       watchedEvent,
                       null
                   );
                   //处理事件
                   processEvent(event);
               }
           },
           builder.getRetryPolicy(),
           builder.canBeReadOnly()
       );

       listeners = new ListenerContainer<CuratorListener>();
       unhandledErrorListeners = new ListenerContainer<UnhandledErrorListener>();
       backgroundOperations = new DelayQueue<OperationAndData<?>>();
       namespace = new NamespaceImpl(this, builder.getNamespace());
       threadFactory = getThreadFactory(builder);
       //初始化连接状态管理器
       connectionStateManager = new ConnectionStateManager(this, builder.getThreadFactory());
       compressionProvider = builder.getCompressionProvider();
       aclProvider = builder.getAclProvider();
       state = new AtomicReference<CuratorFrameworkState>(CuratorFrameworkState.LATENT);

       byte[]      builderDefaultData = builder.getDefaultData();
       defaultData = (builderDefaultData != null) ? Arrays.copyOf(builderDefaultData, builderDefaultData.length) : new byte[0];

       if ( builder.getAuthScheme() != null )
       {
           authInfo.set(new AuthInfo(builder.getAuthScheme(), builder.getAuthValue()));
       }

       failedDeleteManager = new FailedDeleteManager(this);
       namespaceFacadeCache = new NamespaceFacadeCache(this);
   }
   //处理CuratorEvent事件
   private void processEvent(final CuratorEvent curatorEvent)
    {
        if ( curatorEvent.getType() == CuratorEventType.WATCHED )
        {
            validateConnection(curatorEvent.getWatchedEvent().getState());
        }

        listeners.forEach
        (
            new Function<CuratorListener, Void>()
            {
                @Override
                public Void apply(CuratorListener listener)
                {
                    try
                    {
                        TimeTrace trace = client.startTracer("EventListener");
                        listener.eventReceived(CuratorFrameworkImpl.this, curatorEvent);
                        trace.commit();
                    }
                    catch ( Exception e )
                    {
                        logError("Event listener threw exception", e);
                    }
                    return null;
                }
            }
        );
    }
}
```
从上面可以看出，Curator框架实现CuratorFrameworkImpl启动时，首先启动连接状态管理器ConnectionStateManager，然后再启动客户端CuratorZookeeperClient。

再来看CuratorZookeeperClient的启动，


```java
public class CuratorZookeeperClient implements Closeable
{
    private final Logger                            log = LoggerFactory.getLogger(getClass());
    private final ConnectionState                   state;//连接状态
    private final AtomicReference<RetryPolicy>      retryPolicy = new AtomicReference<RetryPolicy>();
    private final int                               connectionTimeoutMs;
    private final AtomicBoolean                     started = new AtomicBoolean(false);
    private final AtomicReference<TracerDriver>     tracer = new AtomicReference<TracerDriver>(new DefaultTracerDriver());
    /**
    *
    * @param connectString list of servers to connect to
    * @param sessionTimeoutMs session timeout
    * @param connectionTimeoutMs connection timeout
    * @param watcher default watcher or null
    * @param retryPolicy the retry policy to use
    */
   public CuratorZookeeperClient(String connectString, int sessionTimeoutMs, int connectionTimeoutMs, Watcher watcher, RetryPolicy retryPolicy)
   {
       this(new DefaultZookeeperFactory(), new FixedEnsembleProvider(connectString), sessionTimeoutMs, connectionTimeoutMs, watcher, retryPolicy, false);
   }

   /**
    * @param ensembleProvider the ensemble provider
    * @param sessionTimeoutMs session timeout
    * @param connectionTimeoutMs connection timeout
    * @param watcher default watcher or null
    * @param retryPolicy the retry policy to use
    */
   public CuratorZookeeperClient(EnsembleProvider ensembleProvider, int sessionTimeoutMs, int connectionTimeoutMs, Watcher watcher, RetryPolicy retryPolicy)
   {
       this(new DefaultZookeeperFactory(), ensembleProvider, sessionTimeoutMs, connectionTimeoutMs, watcher, retryPolicy, false);
   }

   /**
    * @param zookeeperFactory factory for creating {@link ZooKeeper} instances
    * @param ensembleProvider the ensemble provider
    * @param sessionTimeoutMs session timeout
    * @param connectionTimeoutMs connection timeout
    * @param watcher default watcher or null
    * @param retryPolicy the retry policy to use
    * @param canBeReadOnly if true, allow ZooKeeper client to enter
    *                      read only mode in case of a network partition. See
    *                      {@link ZooKeeper#ZooKeeper(String, int, Watcher, long, byte[], boolean)}
    *                      for details
    */
   public CuratorZookeeperClient(ZookeeperFactory zookeeperFactory, EnsembleProvider ensembleProvider, int sessionTimeoutMs, int connectionTimeoutMs, Watcher watcher, RetryPolicy retryPolicy, boolean canBeReadOnly)
   {
       if ( sessionTimeoutMs < connectionTimeoutMs )
       {
           log.warn(String.format("session timeout [%d] is less than connection timeout [%d]", sessionTimeoutMs, connectionTimeoutMs));
       }

       retryPolicy = Preconditions.checkNotNull(retryPolicy, "retryPolicy cannot be null");
       ensembleProvider = Preconditions.checkNotNull(ensembleProvider, "ensembleProvider cannot be null");

       this.connectionTimeoutMs = connectionTimeoutMs;
       //初始化连接连接状态ConnectionState，关键点
       state = new ConnectionState(zookeeperFactory, ensembleProvider, sessionTimeoutMs, connectionTimeoutMs, watcher, tracer, canBeReadOnly);
       setRetryPolicy(retryPolicy);
   }
   /**
     * Must be called after construction
     *
     * @throws IOException errors
     */
    public void     start() throws Exception
    {
        log.debug("Starting");

        if ( !started.compareAndSet(false, true) )
        {
            IllegalStateException error = new IllegalStateException();
            log.error("Already started", error);
            throw error;
        }
        //启动连接状态ConnectionState
        state.start();
    }

```
再来看启动连接状态ConnectionState：

```java
class ConnectionState implements Watcher, Closeable
{
    private static final int MAX_BACKGROUND_EXCEPTIONS = 10;
    private static final boolean LOG_EVENTS = Boolean.getBoolean(DebugUtils.PROPERTY_LOG_EVENTS);
    private final Logger log = LoggerFactory.getLogger(getClass());
    private final HandleHolder zooKeeper;
    private final AtomicBoolean isConnected = new AtomicBoolean(false);
    private final EnsembleProvider ensembleProvider;
    private final int sessionTimeoutMs;
    private final int connectionTimeoutMs;
    private final AtomicReference<TracerDriver> tracer;
    private final Queue<Exception> backgroundExceptions = new ConcurrentLinkedQueue<Exception>();
    //监听器队列
    private final Queue<Watcher> parentWatchers = new ConcurrentLinkedQueue<Watcher>();
    private final AtomicLong instanceIndex = new AtomicLong();
    private volatile long connectionStartMs = 0;

    ConnectionState(ZookeeperFactory zookeeperFactory, EnsembleProvider ensembleProvider, int sessionTimeoutMs, int connectionTimeoutMs, Watcher parentWatcher, AtomicReference<TracerDriver> tracer, boolean canBeReadOnly)
    {
        this.ensembleProvider = ensembleProvider;
        this.sessionTimeoutMs = sessionTimeoutMs;
        this.connectionTimeoutMs = connectionTimeoutMs;
        this.tracer = tracer;
        //添加WACher监听器，关键点
        if ( parentWatcher != null )
        {
            parentWatchers.offer(parentWatcher);
        }

        zooKeeper = new HandleHolder(zookeeperFactory, this, ensembleProvider, sessionTimeoutMs, canBeReadOnly);
    }
    //处理监听事件
    @Override
  public void process(WatchedEvent event)
  {
      if ( LOG_EVENTS )
      {
          log.debug("ConnectState watcher: " + event);
      }

      for ( Watcher parentWatcher : parentWatchers )
      {
          TimeTrace timeTrace = new TimeTrace("connection-state-parent-process", tracer.get());
          parentWatcher.process(event);
          timeTrace.commit();
      }

      boolean wasConnected = isConnected.get();
      boolean newIsConnected = wasConnected;
      if ( event.getType() == Watcher.Event.EventType.None )
      {
          newIsConnected = checkState(event.getState(), wasConnected);
      }

      if ( newIsConnected != wasConnected )
      {
          isConnected.set(newIsConnected);
          connectionStartMs = System.currentTimeMillis();
      }
    }
  }
   void start() throws Exception
  {
      log.debug("Starting");
      ensembleProvider.start();
      reset();
  }
}
```
从上面可以看出，。Curator框架实现CuratorFrameworkImpl启动时，首先启动连接状态管理器ConnectionStateManager，
然后再启动客户端CuratorZookeeperClient(在构造Curator框架实现CuratorFrameworkImpl初始化动客户端CuratorZookeeperClient，传入一个Watcher，用于处理CuratorEvent。)。
启动客户端CuratorZookeeperClient过程，关键点是在启动连接状态ConnectionState（在构造CuratorZookeeperClient，初始化连接状态，并将内部Watcher传给连接状态）。
连接状态实现了观察者Watcher，在连接状态建立时，调用客户端CuratorZookeeperClient传入的Watcher，处理相关事件。而这个Watcher是在现CuratorFrameworkImpl初始化动客户端CuratorZookeeperClient时，
传入的。客户端观察者的实际处理业务逻辑在CuratorFrameworkImpl实现，及processEvent方法，processEvent主要处理逻辑为，遍历Curator框架实现CuratorFrameworkImpl内部的监听器容器内的监听器处理相关CuratorEvent
事件。这个CuratorEvent事件，是由原生WatchedEvent事件包装而来。

结合注册节点监听器，我们来看一下小节一下：



添加节点监听器，实际上是注册到节点缓存的节点监听器容器ListenerContainer<NodeCacheListener>（CuratorFrameworkImpl内部的成员添加节点监听器，实际上是注册到节点缓存的节点监听器容器ListenerContainer）中。
启动节点监听器，实际上是注册节点监听器到CuratorFramework实现的连接状态管理器中ConnectionStateManager。
Curator框架实现CuratorFrameworkImpl启动时，首先启动连接状态管理器ConnectionStateManager，
然后再启动客户端CuratorZookeeperClient(在构造Curator框架实现CuratorFrameworkImpl初始化动客户端CuratorZookeeperClient，传入一个Watcher，用于处理CuratorEvent。)。
启动客户端CuratorZookeeperClient过程，关键点是在启动连接状态ConnectionState（在构造CuratorZookeeperClient，初始化连接状态，并将内部Watcher传给连接状态）。
连接状态实现了观察者Watcher，在连接状态建立时，调用客户端CuratorZookeeperClient传入的Watcher，处理相关事件。而这个Watcher是在现CuratorFrameworkImpl初始化动客户端CuratorZookeeperClient时，
传入的。客户端观察者的实际处理业务逻辑在CuratorFrameworkImpl实现，及processEvent方法，processEvent主要处理逻辑为，遍历Curator框架实现CuratorFrameworkImpl内部的监听器容器内的监听器处理相关CuratorEvent
事件。这个CuratorEvent事件，是由原生WatchedEvent事件包装而来。

```java
```


### 一级目录监听器PathChildrenCache
2. 一级目录监听器PathChildrenCache
```java
PathChildrenCache cache = new PathChildrenCache(client, path, true);
/**
  * After cache is primed with initial values (in the background) a
  * {@link PathChildrenCacheEvent.Type#INITIALIZED} will be posted
  */
cache.start(PathChildrenCache.StartMode.POST_INITIALIZED_EVENT);
cache.getListenable().addListener(new PathChildrenCacheListener() {
     @Override
     public void childEvent(CuratorFramework client,
                            PathChildrenCacheEvent event) throws Exception {
         switch (event.getType()) {
             case CHILD_ADDED:
                 String currentPathValue =  new String(client.getData().storingStatIn(new Stat()).forPath(path),ConfigConstant.CHAR_SET_NAME);
                 log.info("CHILD_ADDED,{},parent node data: {}",event.getData().getPath(), currentPathValue);
                 break;
             case CHILD_UPDATED:
                 log.info("CHILD_UPDATED,{},vaule:{}",event.getData().getPath(), new String(event.getData().getData(),ConfigConstant.CHAR_SET_NAME));
                 break;
             case CHILD_REMOVED:
                 log.info("CHILD_REMOVED,{}",event.getData().getPath());
                 break;
             default:
                 break;
         }
     }
});
```

```java
PathChildrenCache cache = new PathChildrenCache(client, path, true, false, exec);
/**
  * NORMAL,
  * cache will _not_ be primed. i.e. it will start empty and you will receive
  * events for all nodes added, etc.
  */
cache.start(PathChildrenCache.StartMode.NORMAL);
cache.getListenable().addListener(new PathChildrenCacheListener() {
     @Override
     public void childEvent(CuratorFramework client,
                            PathChildrenCacheEvent event) throws Exception {
         switch (event.getType()) {
             case CHILD_ADDED:
                 String currentPathValue =  new String(client.getData().storingStatIn(new Stat()).forPath(path),ConfigConstant.CHAR_SET_NAME);
                 log.info("CHILD_ADDED,{},parent node data: {}",event.getData().getPath(), currentPathValue);
                 log.info( "current thread name:{} ", Thread.currentThread().getName() );
                 break;
             case CHILD_UPDATED:
                 log.info("CHILD_UPDATED,{},vaule:{}",event.getData().getPath(), new String(event.getData().getData(),ConfigConstant.CHAR_SET_NAME));
                 log.info( "current thread name:{} ", Thread.currentThread().getName() );
                 break;
             case CHILD_REMOVED:
                 log.info("CHILD_REMOVED,{}",event.getData().getPath());
                 log.info( "current thread name:{} ", Thread.currentThread().getName() );
                 break;
             default:
                 break;
         }
     }
});
```

```java
```



###


```java
```


## 总结

节点监听缓存NodeCache，内部关联一下Curator框架客户端CuratorFramework，节点监听器容器 listeners（ListenerContainer<NodeCacheListener>），用于
存放节点监听器。添加节点监听器，实际上是注册到节点缓存的节点监听器容器ListenerContainer<NodeCacheListener>中。
启动节点监听器，实际上是注册节点监听器到CuratorFramework实现的连接状态管理器中ConnectionStateManager。
Curator框架实现CuratorFrameworkImpl启动时，首先启动连接状态管理器ConnectionStateManager，然后再启动客户端CuratorZookeeperClient。
