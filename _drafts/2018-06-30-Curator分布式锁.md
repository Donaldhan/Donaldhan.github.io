---
layout: page
title: Curator分布式锁.
subtitle: Curator分布式锁.
date: 2018-06-30 12:00:00
author: donaldhan
catalog: true
category: Zookeeper
categories:
    - Zookeeper
tags:
    - ZkClient
---

# 引言

节点监听缓存NodeCache，内部关联一下Curator框架客户端CuratorFramework，节点监听器容器 listeners（ListenerContainer<NodeCacheListener>），用于
存放节点监听器。

添加节点监听器，实际上是注册到节点缓存的节点监听器容器ListenerContainer<NodeCacheListener>（CuratorFrameworkImpl内部的成员添加节点监听器，实际上是注册到节点缓存的节点监听器容器ListenerContainer）中。
启动节点监听器，实际上是注册节点监听器到CuratorFramework实现的连接状态管理器中ConnectionStateManager，如果需要，则重新构建节点数据，同时重新注册节点监听器CuratorWatcher，如果连接状态有变更，
重新注册节点监听器CuratorWatcher。

Curator框架实现CuratorFrameworkImpl启动时，首先启动连接状态管理器ConnectionStateManager，
然后再启动客户端CuratorZookeeperClient(在构造Curator框架实现CuratorFrameworkImpl初始化动客户端CuratorZookeeperClient，传入一个Watcher，用于处理CuratorEvent。)。
启动客户端CuratorZookeeperClient过程，关键点是在启动连接状态ConnectionState（在构造CuratorZookeeperClient，初始化连接状态，并将内部Watcher传给连接状态）。
连接状态实现了观察者Watcher，在连接状态建立时，调用客户端CuratorZookeeperClient传入的Watcher，处理相关事件。而这个Watcher是在现CuratorFrameworkImpl初始化动客户端CuratorZookeeperClient时，
传入的。客户端观察者的实际处理业务逻辑在CuratorFrameworkImpl实现，及processEvent方法，processEvent主要处理逻辑为，遍历Curator框架实现CuratorFrameworkImpl内部的监听器容器内的监听器处理相关CuratorEvent
事件。这个CuratorEvent事件，是由原生WatchedEvent事件包装而来。

启动连接连接状态管理器，主要是使用连接状态监听器容器ListenerContainer<ConnectionStateListener>中的监听器，消费连接状态事件队列BlockingQueue<ConnectionState>中事件。

子目录监听器PathChildrenCache，主要成员变量为客户端框架实现CuratorFramework，子路径监听器容器ListenerContainer<PathChildrenCacheListener>，及事件执行器CloseableExecutorService，事件操作集Set<Operation>。

一级目录监听器PathChildrenCache，启动主要是注册连接状态监听器ConnectionStateListener，连接状态监听器根据连接状态来添加事件EventOperation和刷新RefreshOperation操作到操作集。
事件操作EventOperation，主要是触发监听器的子目录事件操作；刷新操作RefreshOperation主要是完成子目录的添加和刷新事件，并从新注册子目录监听器。
然后根据启动模式来决定是重添加事件操作，刷新、事件操作，或者重新构建，即刷新缓存路径数据，并注册刷新操作。

关闭客户端框架，主要是清除监听器，连接状态管理器，关闭zk客户端。这是我们上一篇文章[Curator目录监听][]所讲的内容，今天我们来看一下Curator高级特性分布式锁。本文中的所有示例见[zookeeper-demo][]

[Curator目录监听]:https://donaldhan.github.io/zookeeper/2018/06/29/curator%E7%9B%AE%E5%BD%95%E7%9B%91%E5%90%AC.html "Curator目录监听"


# 目录
* [Curator分布式锁](#curator分布式锁.)
    * [分布式可重入锁InterProcessMutex](#分布式可重入锁interprocessmutex)
    * [](#)
* [总结](#总结)

## Curator分布式锁
现在先让我们看看Curator的几种锁方案：
四种锁方案
    InterProcessMutex：分布式可重入排它锁
    InterProcessSemaphoreMutex：分布式排它锁
    InterProcessReadWriteLock：分布式读写锁
    InterProcessMultiLock：将多个锁作为单个实体管理的容器
    DistributedBarrier：使用Curator实现分布式Barrier，实际在分布式环境中使用，待所有应用到达屏障时，移除屏障
    DistributedDoubleBarrier：分布式锁， 控制同时进入，同时退出
今天我们主要探讨的是分布式可重入排它锁InterProcessMutex，先来看一个示例：

```java
package org.donald.curator.recipes.lock;

import lombok.extern.slf4j.Slf4j;
import org.apache.curator.RetryPolicy;
import org.apache.curator.framework.CuratorFramework;
import org.apache.curator.framework.CuratorFrameworkFactory;
import org.apache.curator.framework.recipes.locks.InterProcessMutex;
import org.apache.curator.retry.ExponentialBackoffRetry;
import org.donald.common.threadpool.TaskExecutors;
import org.donald.constant.ConfigConstant;

import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;

/**
 * @ClassName: RecipesLockSample
 * @Description: 测试使用分布式锁的情况下，生成订单id，可以避免产生重复id
 * @Author: Donaldhan
 * @Date: 2018-05-16 16:01
 */
@Slf4j
public class RecipesLockSample {
    private static CuratorFramework client;
    private static ExecutorService exec = null;
    public static void main(String[] args) {
        String lock_path = "/curator_recipes_lock_path";
        //模仿同时生成订单
        final CountDownLatch down = new CountDownLatch(1);
        try {
            RetryPolicy retryPolicy = new ExponentialBackoffRetry(ConfigConstant.BASE_SLEEP_TIMES, ConfigConstant.MAX_RETRIES);
            client =
                    CuratorFrameworkFactory.builder()
                            .connectString(ConfigConstant.IP)
                            .sessionTimeoutMs(ConfigConstant.SESSION_TIMEOUT)
                            .connectionTimeoutMs(ConfigConstant.CONNETING_TIMEOUT)
                            .retryPolicy(retryPolicy)
                            .build();
            client.start();
            log.info("success connected...");
            //分布式锁
            final InterProcessMutex lock = new InterProcessMutex(client,lock_path);
            exec = TaskExecutors.newFixedThreadPool(30);
            for(int i = 0; i < 30; i++){
                exec.submit(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            //模仿同时生成订单
                            down.await();
                            //获取分布式锁
                            lock.acquire();
                            SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss|SSS");
                            String orderNo = sdf.format(new Date());
                            log.info("{} 生成的订单号是 :{} ",Thread.currentThread().getName(), orderNo);

                        } catch ( Exception e ) {
                            e.printStackTrace();
                        }
                        finally {
                            try {
                                lock.release();
                            } catch (Exception e) {
                                e.printStackTrace();
                            }
                        }
                    }
                });
            }
            down.countDown();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            if (exec != null) {
                exec.shutdown();
            }
            /*  如果在会话执行的过程中，关闭会话，将抛出异常
            java.lang.IllegalStateException: instance must be started before calling this method
            if (client != null) {
                client.close();
            }*/
        }
    }
}
```
从上面示例，关键的几个操作为：
```java
//分布式锁
final InterProcessMutex lock = new InterProcessMutex(client,lock_path);
//获取分布式锁
lock.acquire();
  lock.release();
```
分别为创建分布式可重入锁，获取锁，与释放锁。
下面我们来看分布式可重入锁的定义：



### 分布式可重入锁InterProcessMutex
```java
public class InterProcessMutex implements InterProcessLock, Revocable<InterProcessMutex>
{
    private final LockInternals         internals;
    private final String                basePath;
    private final ConcurrentMap<Thread, LockData>   threadData = Maps.newConcurrentMap();
    private static class LockData
    {
        final Thread        owningThread;//拥有线程
        final String        lockPath;//锁路径
        final AtomicInteger lockCount = new AtomicInteger(1);//锁的次数

        private LockData(Thread owningThread, String lockPath)
        {
            this.owningThread = owningThread;
            this.lockPath = lockPath;
        }
    }
    private static final String LOCK_NAME = "lock-";
    /**
     * @param client client
     * @param path the path to lock
     */
    public InterProcessMutex(CuratorFramework client, String path)
    {
        this(client, path, LOCK_NAME, 1, new StandardLockInternalsDriver());
    }
    InterProcessMutex(CuratorFramework client, String path, String lockName, int maxLeases, LockInternalsDriver driver)
    {
        basePath = path;
        internals = new LockInternals(client, driver, path, lockName, maxLeases);
    }
}
```
从上面可以看出，分布式可重入锁InterProcessMutex主要的成员变量为锁路径basePath，持有分布式映射信息映射threadData（ConcurrentMap<Thread, LockData>），同时一个关键的锁实现LockInternals。

我们先来看一下分布式可重入锁接口的定义：
```java
public interface InterProcessLock
{
    /**
     * Acquire the mutex - blocking until it's available. Each call to acquire must be balanced by a call
     * to {@link #release()}
     *
     * @throws Exception ZK errors, connection interruptions
     */
    public void acquire() throws Exception;

    /**
     * Acquire the mutex - blocks until it's available or the given time expires. Each call to acquire that returns true must be balanced by a call
     * to {@link #release()}
     *
     * @param time time to wait
     * @param unit time unit
     * @return true if the mutex was acquired, false if not
     * @throws Exception ZK errors, connection interruptions
     */
    public boolean acquire(long time, TimeUnit unit) throws Exception;

    /**
     * Perform one release of the mutex.
     *
     * @throws Exception ZK errors, interruptions, current thread does not own the lock
     */
    public void release() throws Exception;

    /**
     * Returns true if the mutex is acquired by a thread in this JVM
     *
     * @return true/false
     */
    boolean isAcquiredInThisProcess();
}
```
从上面可以分布式可重入锁，主要提供的获取释放锁，和检查当前线程是否持有锁操作。

再来看分布式可重入锁实现接口Revocable定义：

```java
/**
 * Specifies locks that can be revoked
 可释放锁
 */
public interface Revocable<T>
{
    /**
     * Make the lock revocable. Your listener will get called when another process/thread
     * wants you to release the lock. Revocation is cooperative.
     * 锁释放时，触发监听器
     * @param listener the listener
     */
    public void     makeRevocable(RevocationListener<T> listener);

    /**
     * Make the lock revocable. Your listener will get called when another process/thread
     * wants you to release the lock. Revocation is cooperative.
     *
     * @param listener the listener
     * @param executor executor for the listener
     */
    public void     makeRevocable(RevocationListener<T> listener, Executor executor);
}
//锁释放信号监听器
public interface RevocationListener<T>
{
    /**
     * Called when a revocation request has been received. You should release the lock as soon
     * as possible. Revocation is cooperative.
     * 当锁被释放时，触发此方法
     * @param forLock the lock that should release
     */
    public void         revocationRequested(T forLock);
}
```
从上面可以看出Revocable的作用，主要是在锁释放的时候，触发释放锁监听器RevocationListener，同时我们可以使用自己的执行器，触发相关监听器操作。

在构造分布式可重入锁的是有一个锁驱动StandardLockInternalsDriver我们来看一下。
```java
/**
  * @param client client
  * @param path the path to lock
  */
 public InterProcessMutex(CuratorFramework client, String path)
 {
     this(client, path, LOCK_NAME, 1, new StandardLockInternalsDriver());
 }
```

```java
public class StandardLockInternalsDriver implements LockInternalsDriver
{
    static private final Logger log = LoggerFactory.getLogger(StandardLockInternalsDriver.class);

    @Override
    public PredicateResults getsTheLock(CuratorFramework client, List<String> children, String sequenceNodeName, int maxLeases) throws Exception
    {
        //获取序列节点的索引
        int             ourIndex = children.indexOf(sequenceNodeName);
        //校验索引
        validateOurIndex(sequenceNodeName, ourIndex);
        //
        boolean         getsTheLock = ourIndex < maxLeases;
        //锁路径
        String          pathToWatch = getsTheLock ? null : children.get(ourIndex - maxLeases);

        return new PredicateResults(pathToWatch, getsTheLock);
    }

    @Override
    public String fixForSorting(String str, String lockName)
    {
        return standardFixForSorting(str, lockName);
    }

    public static String standardFixForSorting(String str, String lockName)
    {
        int index = str.lastIndexOf(lockName);
        if ( index >= 0 )
        {
            index += lockName.length();
            return index <= str.length() ? str.substring(index) : "";
        }
        return str;
    }

    static void validateOurIndex(String sequenceNodeName, int ourIndex) throws KeeperException
    {
        if ( ourIndex < 0 )
        {
            log.error("Sequential path not found: " + sequenceNodeName);
            throw new KeeperException.NoNodeException("Sequential path not found: " + sequenceNodeName);
        }
    }
}
//锁内部驱动
interface LockInternalsDriver extends LockInternalsSorter
{
    //尝试获取锁
    public PredicateResults getsTheLock(CuratorFramework client, List<String> children, String sequenceNodeName, int maxLeases) throws Exception;
}
//预测结果
class PredicateResults
{
    private final boolean   getsTheLock;//是否成功获取锁
    private final String    pathToWatch;//锁路径

    PredicateResults(String pathToWatch, boolean getsTheLock)
    {
        this.pathToWatch = pathToWatch;
        this.getsTheLock = getsTheLock;
    }

    String getPathToWatch()
    {
        return pathToWatch;
    }

    boolean getsTheLock()
    {
        return getsTheLock;
    }
}
```

来看LockInternals的定义：

```java
public class LockInternals
{
    private final CuratorFramework                  client;//框架客户端
    private final String                            path;
    private final String                            basePath;//锁路径
    private final LockInternalsDriver               driver;//锁内部驱动
    private final String                            lockName;
    //释放线程执行器对
    private final AtomicReference<RevocationSpec>   revocable = new AtomicReference<RevocationSpec>(null);
    private volatile int    maxLeases;//最大可重入锁
    static final byte[]             REVOKE_MESSAGE = "__REVOKE__".getBytes();//释放数据
    LockInternals(CuratorFramework client, LockInternalsDriver driver, String path, String lockName, int maxLeases)
    {
        this.driver = driver;
        this.lockName = lockName;
        this.maxLeases = maxLeases;
        PathUtils.validatePath(path);

        this.client = client;
        this.basePath = path;
        this.path = ZKPaths.makePath(path, lockName);
    }
    //检查锁路径是否可用观察器
    private final CuratorWatcher                    revocableWatcher = new CuratorWatcher()
   {
       @Override
       public void process(WatchedEvent event) throws Exception
       {
           if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )
           {
               checkRevocableWatcher(event.getPath());
           }
       }
   };
   private final Watcher watcher = new Watcher()
   {
       @Override
       public void process(WatchedEvent event)
       {
           notifyFromWatcher();
       }
   };
}
//释放线程执行器对
class RevocationSpec
{
    private final Runnable      runnable;//任务线程
    private final Executor      executor;//任务执行器

    RevocationSpec(Executor executor, Runnable runnable)
    {
        this.runnable = runnable;
        this.executor = executor;
    }

    Runnable getRunnable()
    {
        return runnable;
    }

    Executor getExecutor()
    {
        return executor;
    }
}
```
从上面可以看出LockInternals主要的成员变量为客户端框架CuratorFramework，锁内部驱动LockInternalsDriver，检查锁路径是否可用观察器CuratorWatcher，唤醒所有等待锁线程观察器Watcher。

我们来看一下LockInternals两个内部成员revocableWatcher，watcher

```java
private final CuratorWatcher                    revocableWatcher = new CuratorWatcher()
{
   @Override
   public void process(WatchedEvent event) throws Exception
   {
       if ( event.getType() == Watcher.Event.EventType.NodeDataChanged )
       {
           checkRevocableWatcher(event.getPath());
       }
   }
};
private void checkRevocableWatcher(String path) throws Exception
{
    //获取线程执行器对
    RevocationSpec  entry = revocable.get();
    if ( entry != null )
    {
        try
        {
          //获取所路径数据，并重新注册监听
            byte[]      bytes = client.getData().usingWatcher(revocableWatcher).forPath(path);
            if ( Arrays.equals(bytes, REVOKE_MESSAGE) )
            {
                //如果数据为取消锁，执行相应的任务线程
                entry.getExecutor().execute(entry.getRunnable());
            }
        }
        catch ( KeeperException.NoNodeException ignore )
        {
            // ignore
        }
    }
}
```


```java
//唤醒所有等待获取锁的线程
private final Watcher watcher = new Watcher()
{
    @Override
    public void process(WatchedEvent event)
    {
        notifyFromWatcher();
    }
};
private synchronized void notifyFromWatcher()
   {
       notifyAll();
   }
}
```


现在回到分布式事务锁的InterProcessMutex获取锁操作

```java
//InterProcessMutex
/**
  * Acquire the mutex - blocking until it's available. Note: the same thread
  * can call acquire re-entrantly. Each call to acquire must be balanced by a call
  * to {@link #release()}
  * 尝试获取锁，阻塞到直到锁可用
  * @throws Exception ZK errors, connection interruptions
  */
@Override
public void acquire() throws Exception
{
     if ( !internalLock(-1, null) )
     {
         throw new IOException("Lost connection while trying to acquire lock: " + basePath);
     }
}
private boolean internalLock(long time, TimeUnit unit) throws Exception
{
    /*
       Note on concurrency: a given lockData instance
       can be only acted on by a single thread so locking isn't necessary
    */

    Thread          currentThread = Thread.currentThread();

    LockData        lockData = threadData.get(currentThread);
    if ( lockData != null )
    {
        //当前线程已经持有锁，则重入计数器自增
        // re-entering
        lockData.lockCount.incrementAndGet();
        return true;
    }
    // 否则尝试获取锁
    String lockPath = internals.attemptLock(time, unit, getLockNodeBytes());
    if ( lockPath != null )
    {
        //如果获取锁成功，则将锁数据存放的锁信息映射中
        LockData        newLockData = new LockData(currentThread, lockPath);
        threadData.put(currentThread, newLockData);
        return true;
    }

    return false;
}
```
我们来看获取锁的关键点
```java
//LockInternals
String attemptLock(long time, TimeUnit unit, byte[] lockNodeBytes) throws Exception
{
    final long      startMillis = System.currentTimeMillis();
    final Long      millisToWait = (unit != null) ? unit.toMillis(time) : null;
    //锁数据
    final byte[]    localLockNodeBytes = (revocable.get() != null) ? new byte[0] : lockNodeBytes;
    int             retryCount = 0;

    String          ourPath = null;
    boolean         hasTheLock = false;
    boolean         isDone = false;
    while ( !isDone )
    {
        isDone = true;

        try
        {
            //创建路径成功，则成功获取锁
            if ( localLockNodeBytes != null )
            {
                ourPath = client.create().creatingParentsIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path, localLockNodeBytes);
            }
            else
            {
                ourPath = client.create().creatingParentsIfNeeded().withProtection().withMode(CreateMode.EPHEMERAL_SEQUENTIAL).forPath(path);
            }
            hasTheLock = internalLockLoop(startMillis, millisToWait, ourPath);
        }
        catch ( KeeperException.NoNodeException e )
        {
            //创建路径失败，则获取锁失败
            // gets thrown by StandardLockInternalsDriver when it can't find the lock node
            // this can happen when the session expires, etc. So, if the retry allows, just try it all again
            if ( client.getZookeeperClient().getRetryPolicy().allowRetry(retryCount++, System.currentTimeMillis() - startMillis, RetryLoop.getDefaultRetrySleeper()) )
            {
                isDone = false;
            }
            else
            {
                throw e;
            }
        }
    }

    if ( hasTheLock )
    {
        return ourPath;
    }

    return null;
}
//
private boolean internalLockLoop(long startMillis, Long millisToWait, String ourPath) throws Exception
{
    boolean     haveTheLock = false;
    boolean     doDelete = false;
    try
    {
        if ( revocable.get() != null )
        {
            //如果存在尝试获取锁线程，不为空，则监听路径，并注册检查锁可用监听器
            client.getData().usingWatcher(revocableWatcher).forPath(ourPath);
        }

        while ( (client.getState() == CuratorFrameworkState.STARTED) && !haveTheLock )
        {
            List<String>        children = getSortedChildren();//获取锁路径，子目录
            String              sequenceNodeName = ourPath.substring(basePath.length() + 1); // +1 to include the slash
            //尝试从驱动获取锁
            PredicateResults    predicateResults = driver.getsTheLock(client, children, sequenceNodeName, maxLeases);
            if ( predicateResults.getsTheLock() )
            {
                //获取锁成功
                haveTheLock = true;
            }
            else
            {
               //获取锁路径
                String  previousSequencePath = basePath + "/" + predicateResults.getPathToWatch();
                synchronized(this)
                {
                    //监控锁释放
                    Stat stat = client.checkExists().usingWatcher(watcher).forPath(previousSequencePath);
                    if ( stat != null )
                    {
                        if ( millisToWait != null )
                        {
                            millisToWait -= (System.currentTimeMillis() - startMillis);
                            startMillis = System.currentTimeMillis();
                            if ( millisToWait <= 0 )
                            {
                                doDelete = true;    // timed out - delete our node
                                break;
                            }

                            wait(millisToWait);
                        }
                        else
                        {
                            wait();
                        }
                    }
                }
                // else it may have been deleted (i.e. lock released). Try to acquire again
            }
        }
    }
    catch ( Exception e )
    {
        doDelete = true;
        throw e;
    }
    finally
    {
        if ( doDelete )
        {
            //获取锁异常，则删除锁目录下的临时序列目录
            deleteOurPath(ourPath);
        }
    }
    return haveTheLock;
}
//StandardLockInternalsDriver
@Override
   public PredicateResults getsTheLock(CuratorFramework client, List<String> children, String sequenceNodeName, int maxLeases) throws Exception
   {
       int             ourIndex = children.indexOf(sequenceNodeName);
       validateOurIndex(sequenceNodeName, ourIndex);
       boolean         getsTheLock = ourIndex < maxLeases;
       //检查锁路径下，是否存在给定的序列路径
       String          pathToWatch = getsTheLock ? null : children.get(ourIndex - maxLeases);

       return new PredicateResults(pathToWatch, getsTheLock);
   }
```

再看看一下删除锁锁目录下的临时序列目录
```java
private void deleteOurPath(String ourPath) throws Exception
{
    try
    {
        client.delete().guaranteed().forPath(ourPath);
    }
    catch ( KeeperException.NoNodeException e )
    {
        // ignore - already deleted (possibly expired session, etc.)
    }
}
```

再来看一下//获取锁路径，子目录：
```java
List<String> getSortedChildren() throws Exception
  {
      return getSortedChildren(client, basePath, lockName, driver);
  }

public static List<String> getSortedChildren(CuratorFramework client, String basePath, final String lockName, final LockInternalsSorter sorter) throws Exception
{
    List<String> children = client.getChildren().forPath(basePath);
    List<String> sortedList = Lists.newArrayList(children);
    Collections.sort
    (
        sortedList,
        new Comparator<String>()
        {
            @Override
            public int compare(String lhs, String rhs)
            {
                return sorter.fixForSorting(lhs, lockName).compareTo(sorter.fixForSorting(rhs, lockName));
            }
        }
    );
    return sortedList;
}
//StandardLockInternalsDriver
@Override
public String fixForSorting(String str, String lockName)
{
    return standardFixForSorting(str, lockName);
}

public static String standardFixForSorting(String str, String lockName)
{
    int index = str.lastIndexOf(lockName);
    if ( index >= 0 )
    {
        index += lockName.length();
        return index <= str.length() ? str.substring(index) : "";
    }
    return str;
}
```
从上面可以看出分布式事务锁的InterProcessMutex获取锁操作，首先检查当前线程是否持有锁，如果只有则则重入计数器自增，否则尝试获取锁，如果获取成功，则则将锁数据存放的锁信息映射中threadData（ConcurrentMap<Thread, LockData>），如果获取锁失败，
则等待锁释放，等待锁释放的过程，即注册锁路径是否可用观察器，是否可以获取锁的过程是查看是否可以创建锁目录下的临时序列目录，获取锁异常，则删除锁目录下的临时序列目录。

来看释放锁

```java
/**
 * Perform one release of the mutex if the calling thread is the same thread that acquired it. If the
 * thread had made multiple calls to acquire, the mutex will still be held when this method returns.
 *
 * @throws Exception ZK errors, interruptions, current thread does not own the lock
 */
@Override
public void release() throws Exception
{
    /*
        Note on concurrency: a given lockData instance
        can be only acted on by a single thread so locking isn't necessary
     */

    Thread      currentThread = Thread.currentThread();
    LockData    lockData = threadData.get(currentThread);
    if ( lockData == null )
    {
        
        throw new IllegalMonitorStateException("You do not own the lock: " + basePath);
    }

    int newLockCount = lockData.lockCount.decrementAndGet();
    if ( newLockCount > 0 )
    {
        return;
    }
    if ( newLockCount < 0 )
    {
        throw new IllegalMonitorStateException("Lock count has gone negative for lock: " + basePath);
    }
    try
    {
        internals.releaseLock(lockData.lockPath);
    }
    finally
    {
        threadData.remove(currentThread);
    }
}
```
###


```java
```


## 总结

分布式可重入锁InterProcessMutex主要的成员变量为锁路径basePath，持有分布式映射信息映射threadData（ConcurrentMap<Thread, LockData>），同时一个关键的锁实现LockInternals。

分布式可重入锁，主要提供的获取释放锁，和检查当前线程是否持有锁操作。

Revocable的作用，主要是在锁释放的时候，触发释放锁监听器RevocationListener，同时我们可以使用自己的执行器，触发相关监听器操作。


LockInternals主要的成员变量为客户端框架CuratorFramework，锁内部驱动LockInternalsDriver，检查锁路径是否可用观察器CuratorWatcher，唤醒所有等待锁线程观察器Watcher。

分布式事务锁的InterProcessMutex获取锁操作，首先检查当前线程是否持有锁，如果只有则则重入计数器自增，否则尝试获取锁，如果获取成功，则则将锁数据存放的锁信息映射中threadData（ConcurrentMap<Thread, LockData>），如果获取锁失败，
则等待锁释放，等待锁释放的过程，即注册锁路径是否可用观察器，是否可以获取锁的过程是查看是否可以创建锁目录下的临时序列目录，获取锁异常，则删除锁目录下的临时序列目录。
